

## 问题3 spring IOC 和 AOP

spring 目前Release 4.3.8  http://projects.spring.io/spring-framework/

[官方文档](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/index.html)

参考博客 

### IOC

####定义

IOC（DI）：java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object（） 这样的语法来完成合作对象的申请工作。你会发现：对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。

我的理解就是，业务对象之间的协作关系交由容器工厂去创建。

####简单的场景

我需要完成一个通用性的树的加载组件，该组件需要可以适配DB、LDAP两种数据源，并且可以给出xml、json格式的数据。

- 要完成树的加载需要三个方法：获取根节点，获取某个节点下的子节点，获取某个节点下的所有子节点。
- 通过分析要想实现这样一个组件还需要两个协助对象：从具体数据源取得数据对象，将数据客户化为对应格式的数据。

以上思考相应代码定义。

- 通用树加载组件commenTree 类定义：
![commenTree定义](3-ioc1.png "commenTree定义")
- 从数据源取得数据 ITree接口定义：
![ITree接口定义](3-ioc2.png "ITree接口定义")
- 将数据格式化为对应格式数据 Wrapper接口定义：
![Wrapper接口定义](3-ioc3.png "Wrapper接口定义")

由于需要支持DB、ldap两种数据源所以实现了LdapTree和DBTree。
由于需要支持xml、json的格式化数据所以实现了XmlWrapper和JsonWrapper

使用xml对业务中可能会使用到的对象进行定义：
![xml对象定义](3-ioc4.png "xml对象定义")

main函数，从xml配置中取得可使用的对象，如下根据具体的实际业务需要进行取得即可：
        ApplicationContext context = new FileSystemXmlApplicationContext(
                "applicationContext.xml");

        CommenTree xmlldapTree = (CommenTree)context.getBean("xmlldapTree");
        System.out.println(xmlldapTree.getRoot());


        CommenTree jsonldapTree = (CommenTree)context.getBean("jsonldapTree");
        System.out.println(jsonldapTree.getRoot());


        CommenTree xmldbTree = (CommenTree)context.getBean("xmldbTree");
        System.out.println(xmldbTree.getRoot());


        CommenTree jsondbTree = (CommenTree)context.getBean("jsondbTree");
        System.out.println(jsondbTree.getRoot());


[源码](ioc-src.zip)

以上即为容器最核心的部分，读取配置，根据定义实例化对象，在业务代码中使用对象。其他的高级用户都是对这几个步骤的扩展，比如读取配置实例化对象可以使用注解的形式。

### AOP

#### 定义
AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。
AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。

实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。

#### 相关概念
- 方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 - Advisor或拦截器实现。
- 连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。
 
- 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架- 包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, - ThrowAdvice和DynamicIntroductionAdvice
 
- 切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 - Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， - MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上
 
- 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 - IsModified接口，来简化缓存。Spring中要使用Introduction, - 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口

- 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO
- AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。
- 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。意思就是改变代码的结果的过程。

#### 使用场景

- Authentication 权限
- Caching 缓存
- Context passing 内容传递
- Error handling 错误处理
- Lazy loading　懒加载
- Debugging　　调试
- logging, tracing, profiling and monitoring　记录跟踪　优化　校准
- Performance optimization　性能优化
- Persistence　　持久化
- Resource pooling　资源池
- Synchronization　同步
- Transactions 事务


####  场景实现
继续试用ioc过程中的例子，实现对CommenTree类中方法的两个目标
- 进入方法前后记录日志
- 记录方法的运行时间

applicationContext.xml 增加配置

        <bean id="log" class="aop.Log">
        </bean>
        <context:component-scan
                base-package="com.sugar.ioc" />
        <aop:config>
            <aop:aspect ref="log">
                <aop:pointcut
                        expression="(execution(* com.sugar.ioc.CommenTree.*(..)))"
                        id="treePointCut" />
                <aop:around method="funcTime" pointcut-ref="treePointCut"/>
            </aop:aspect>
        </aop:config>


配置说明
- 使用<aop:config/>标签 定义aop； 
- <aop:aspect> 定义切面； 
- <aop:pointcut/> 定义切入点 
- <aop:before/>和<aop:after/>、<aop:around/>等定义切点的前后方法，around中可以执行运行方法的操作。

expression内容说明（了解就行了，感觉不会问）
execution(* spring.ch3.topic1.Chief.*(..)) 
- 第一颗星表示返回任意类型； 
- com.sugar.ioc.代表包名； 
- CommenTree代表那个类； 
- *(..)代表任意方法，里面的..表示任何参数 
- 也可以简单点，全是用*这个东西来标注，不过一般不这样做，因为每一个切点对应的应该是不同的方法。

aop.Log 定义

![aop.Log](3-aop1.png "aop.Log")

funcTIme方法：

        public Object funcTime(ProceedingJoinPoint joinPoint) throws Throwable {
            funcIn(joinPoint);
            long startTime = System.currentTimeMillis();//记录开始时间
            Object object = joinPoint.proceed();
            //类似于after执行后
            long endTime = System.currentTimeMillis();
            System.out.println("该方法执行时间为: " + (endTime - startTime));
            System.out.println("退出方法,返回值为:"+ object.toString());
            return object;
        }

运行方式和在ioc中类似

        ApplicationContext context = new FileSystemXmlApplicationContext(
                "applicationContext.xml");
        CommenTree xmlldapTree = (CommenTree)context.getBean("xmlldapTree");
        System.out.println(xmlldapTree.getRoot());
        System.out.println(xmlldapTree.getOneLevel("xxxxx"));

运行结果为：

![运行结果](3-aop2.png "运行结果")

[源码](aop-src.zip)

## 问题4 java 6 7 8 的区别（实际应该是新特性）

java9已经有试用版本了
[新特性详细说明](https://segmentfault.com/a/1190000004419611)
下面只做记录

### java6 特性

- JSR199--Java Compiler API
- JSR269--Pluggable Annotation Processing API 通用的Annotations支持
- 支持JDBC4.0规范
- JAX-WS 2.0规范


### java7 特性

- suppress异常(新语法)
- 捕获多个异常(新语法)
- try-with-resources(新语法)
- JSR341-Expression Language Specification(新规范)
- JSR203-More New I/O APIs for the Java Platform(新规范)
- JSR292与InvokeDynamic
- 支持JDBC4.1规范
- Path接口、DirectoryStream、Files、WatchService
- jcmd
- fork/join framework
- Java Mission Control



### java8 特性

- lamda表达式(重磅)
- 集合的stream操作
- 提升HashMaps的性能
- Date-Time Package
- java.lang and java.util Packages
- Concurrency